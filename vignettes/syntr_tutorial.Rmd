---
title: "syntR Tutorial"
author: "Kate Ostevik and Kieran Samuk"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{syntR Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 6,
  fig.width = 6
)


```
# What is syntR?

syntR is an R package for identifying synteny blocks shared between two genetic maps. The core algorithm implemented in the package focuses on identifying synteny blocks via comparison of marker orders (e.g. from maps of different species or populations). syntR identifies synteny blocks using a clustering algorithm tuned to the linear nature of genetic map data and generates an annotated list synteny block membership for each marker.

# Requirements

syntR requires marker positions (chromosome and map position for each markers) from two genetic maps. The marker orders in the two maps need to be separately inferred for each map prior to using syntR. If you need to build you maps prior to using syntR, we reccomend looking into [R/qtl](http://www.rqtl.org/), [ASMap](https://cran.r-project.org/web/packages/ASMap/index.html), and [Lep-MAP](https://sourceforge.net/p/lep-map3/wiki/LM3%20Home/).

# Input File

The input file has six columns. Each row represents the map position of a single marker (e.g. a SNP, a microsatillite, etc.) in two different maps.

```{r input_example, echo=FALSE, message=FALSE}

library("syntR")

data(ann_pet_map)
knitr::kable(head(ann_pet_map), caption = "The example input file")

```

The columns contents are as follows:

- **map1_name**: A unique identifier for the marker. In this case, the markers are named based on where they reside in the sunflower reference genome (determined by aligning GBS reads).
- **map1_chr**: The chromosome on which the marker resides in the first map 
- **map1_pos**: The map position (e.g. in cM) of the marker in the first map
- **map2_name**: As above, but for map2. These could be identical to the map1_names, or not, depending on your marker classification scheme.
- **map2_chr**: The chromosome on which the marker resides in the second map 
- **map2_pos**: The map position of the marker in the second map

# Example Workflow
Below, we work through an example using genetic map data from two sunflower species. Note that some of the details and tuning parameters will require tailoring to your specific maps. Most of these can be inferred from properties of the map data (e.g. the error rates).

## 1. Load and format the map data

We begin by loading the example data:

```{r read_map}
# install the package if needed!
# devtools::install_github("ksamuk/syntR")

# load the syntR package
library("syntR")

# load the example marker data
data(ann_pet_map)
as_tibble(ann_pet_map)

# read in list of chromosome lengths for map1
# this is an optional file that defines the 
# maximum length of each chromosome (in cM) if this is known
data(ann_chr_lengths)
ann_chr_lengths

# make_one_map places all the markers on a single scale
# and adds padding between the chromosomes 
# to aid the algorithm and for visualization purposes
map_list <- make_one_map(ann_pet_map, map1_max_chr_lengths = ann_chr_lengths)

```

## 2. Reordering and the map


```{r plot_map}
# plot map
plot_maps(map_df = map_list[[1]], map1_chrom_breaks = map_list[[2]], map2_chrom_breaks = map_list[[3]])

```

```{r reorder_map}
# reorder and flip some chromosomes
map2_chr_order <- c("Pet8", "Pet9", "Pet12_16", "Pet15", "Pet16_17", "Pet17")
flip_chrs <- c("Pet9")
map_list <- make_one_map(ann_pet_map, map1_max_chr_lengths = ann_chr_lengths, map2_chr_order = map2_chr_order, flip_chrs = flip_chrs)
plot_maps(map_df = map_list[[1]], map1_chrom_breaks = map_list[[2]], map2_chrom_breaks = map_list[[3]])

```

## 3. Determine optimal turning parameters 

The key tuning parameters are max_cluster_range and, to a lesser extent, max_nn_dist. A simple method of finding the optimal combination of these two parameters is to simply fit a range of values and choose values that maximize coverage (% of the map assigned to synteny blocks) of the two maps.

We provide a method for achieving this below. Note it is slightly computationally intensive and may take several minutes to complete.

```{r find_params, echo=FALSE}
# find best parameter combination
# run find_synteny_blocks with each parameter combination and collect summary statistics
parameter_data <- test_parameters(map_list, max_cluster_range_list = seq(1, 5, by = 0.5), max_nn_dist_list = seq(10, 50, by = 10))
plot_summary_stats(parameter_data[[1]], "composite")

# 
# based on pick max_cluster_range = 2 and max_nn_dist = 10

```

We employ simple "elbow" heuristic is to choose the first coverage peak in the parameter matrix (going from low to high on both axes). Based on the above plot, we choose a max_cluster_range of 2 and a max_nn_dist of 10.

# 4. Identify synteny blocks

With the two tuning parameters determined, we can run the primary function of syntR: `find_synteny_blocks()`. 

```{r find_blocks}
# find synteny blocks
map_all_dfs <- find_synteny_blocks(map_list, max_cluster_range = 2, max_nn_dist = 10, plots = TRUE)
map_all_dfs[[2]]
map_all_dfs[[5]]

# plot synteny block orientations
map_all_dfs[[1]] %>%
    plot_maps(map_list[[2]], map_list[[3]], col = c("blue", "grey", "red", "black")[as.numeric(as.factor(.$orientation))], 
              main = "Synteny block orientation",  cex_val = 0.75)

```


  

Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
